---
title: 函数式编程
date: 2022-07-15 17:00:01
updated: 2022-07-18 23:36:00
tags: 基础遍历
categories: JavaScript
keywords:
description:
top_img: https://sls-cloudfunction-ap-guangzhou-code-1300044145.file.myqcloud.com/upload/202207152125946.png
comments:
cover: https://sls-cloudfunction-ap-guangzhou-code-1300044145.file.myqcloud.com/upload/202207152125946.png
toc:
toc_number:
toc_style_simple:
copyright:
copyright_author:
copyright_author_href:
copyright_url:
copyright_info:
mathjax:
katex:
aplayer:
highlight_shrink:
aside:
---

# 函数式编程

Functional Programming， FP，属于一种编程范式，同纬度的还有面向过程，面向对象编程。

## 优势

- 函数式编程抛弃this
- 可以更好的tree shaking
- 方便测试，方便并行处理
- 有很多库可以帮助我们实现函数式编程：lodash，underscore，ramde



函数式编程指的是，输入和输出的映射关系，例如 y = f(x)，描述 x 和 y的关系，这就称为函数。



# 高阶函数（Higher-order function）

## 特征

- 函数作为参数，传递给另外一个函数
- 可以把函数作为另一个函数的返回结果

满足任意一特征的函数，即可称为高阶函数。



**函数作为参数，实现一个forEach函数**

```javascript
function forEach(arr, fn){
  for(let i=0;i<arr.length;i++){
    fn(arr[i])
  }
}

const arr = [1,2,3,4,5]
forEach(arr, (i)=>console.log(i))
```



**函数作为返回值，实现一个once函数（包装后的函数，最多只能被调用一次）**

```javascript
function once(fn){
  let isDone = false
  return function(){
    if(isDone) return 
    isDone = true
    fn.apply(this, arguments)
  }
}

const logMsg = once(() => {
  console.log('message!!')
})

logMsg() // ----> message!!
logMsg() // 未执行
logMsg() // 未执行
```

​	

## 优势

- 抽象可以帮助我们屏蔽细节，只需关注我们的目标
- 高阶函数是用来抽象通用的问题



# 闭包（Closure）

## 特征

在一个作用域下访问到另一个函数内部的函数并访问到函数内部的成员变量



**通过函数的返回值，访问该函数内部的成员变量count**

```javascript
function callCounter(){
  let count = 0;
  return function(){
    count ++
    console.log(`已经调用了${count}次!!`)
  }
}

const logCount = callCounter()

logCount()
logCount()
logCount()
```



**闭包本质来说，执行栈上执行的函数，执行完毕后内存会移除函数内部声明的变量，但如果函数内部如果有向外暴露引用（闭包），则该函数内部的成员变量不会被释放**



# 纯函数

函数式编程的核心，函数式编程中的函数，指的就是纯函数。

**纯函数："相同输入始终会得到相同的输出"**

没有任何可观察的副作用，计算过程中是无状态的。

在JavaScript中，有许多API，其中一部分API就属于纯函数，一部分不属于纯函数（比如数组的slice即为纯函数，而splice不是纯函数，即会改变原数组）



## 优势

- 可缓存
  - 因为纯函数相同的输入始终具有相同输出
- 更容易测试
  - 因为一定有输入和输出，所以纯函数的测试更加方便
- 并行处理
  - 纯函数只依赖参数，不需要访问共享的内存数据，所以可以在任意环境下运行纯函数



## 副作用

一个纯函数是没有任何副作用的，如果一个函数依赖外部的状态，那么他的输入和输出就会变得不可控，即为带来了副作用

```javascript
// 不纯函数
let min = 18
function checkAge(age){
  return age >= min
}

// 纯函数（有硬编码，可通过柯里化解决）
function checkAge(age){
  let min = 18
  return age >= min
}
```

副作用的来源：

- 配置文件
- 数据库
- 用户输入
- ......

所有外部交互都有可能带来副作用，副作用使得函数的通用性下降，同时副作用有时也会带来一些安全隐患譬如XSS攻击，但是副作用却又**不可能完全禁止，尽可能控制他们在可控范围内发生**。



# 柯里化（Currying）

- 当一个函数有多个参数的时候，先传递一部分参数调用它（这部分参数以后永远不变）
- 返回一个新的函数接收剩余的参数，输出结果



## lodash中的curry

```javascript
const _ = require('lodash')

function getSum(a,b,c){
  return a + b + c
}

const curried = _.curry(getSum)

console.log(curried(1)(2)(3))
```

